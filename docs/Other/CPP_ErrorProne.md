# C++ Error Prone

C++ 易错点

## 2016

#### 1.关于循环的循环次数

&emsp; 注意最后一次是完成循环内操作后，再进入下一次循环才判断不符合条件跳出循环的

#### 2.关于参数的引用

&emsp; 函数中带&的是引用传值，不加的是普通传值，带&的可以修改传入变量值

#### 3.关于析构函数的调用时机

- 在main里面声明了一个类A那么\~A()会在main结束时调用
- 如果在自定义的函数f()里面声明了一个A函数f结束的时候就会调用~A()
- 或者delete 指向A的指针
- 或者显式调用析构函数

#### 4.变量生命周期、访问权限等问题

&emsp; 例如：用::a在函数内部调用外部的一个同名全局变量

#### 5.二维数组的初始化方式

&emsp; 如：能够在带值初始化时省略行数而不能省略列数

&emsp; Char str[][10]={“123”,”1234567890”,”36”};

#### 6.对于指向二维字符数组的字符型指针，输出用%s

#### ~~7.链表的运用（大题）要关注并多加练习~~{docsify-ignore}

#### ~~8.关于类，以及new、delete等的用法（大题）~~{docsify-ignore}

#### ~~9.输入输出终止条件判断等~~{docsify-ignore}

#### ~~10.定义类的大题注意类的完整性，析构、构造函数，main方法构造对象测试等。~~{docsify-ignore}

## 2015

#### 1.setw(int n)：仅对紧跟其后的输出内容起作用，包含输出内容一共输出n个位置，内容右对齐；

	setfill(‘*’)<<setw(5)：配合使用可以用其他符号代替空格来填充。

#### 2.函数传参时即使未传指针引用，改变指针指向地址的内容依然有效。

#### 3.Strlen不包含最后’\0’的长度；

	strcat(char *a, char* b)：连接a与b，结果放到a中，ab指针区域不可重叠且a需有足够的空间。

#### 4.关于函数返回值：

- 引用类型不可返回局部对象的引用；
- 引用类型不可返回指向局部对象的指针；
- const用于返回不可修改的对象。

#### 5.子类调用基类函数时函数内部所调用的依然是自身变量。

#### 6.默认参数的函数：
- 默认参数应从右至左逐个定义，中间不可有间隔；
- 调用函数时若要重新赋值默认参数，则从左至右逐个匹配；
- 允许默认参数为函数。

#### 7.构造、析构函数均为公有。

## 2014

#### 1.类与函数定义在main函数之后时需要先声明后使用

#### 2.函数声明和定义不能都定义默认参数

&emsp; 当同时存在声明和定义时只能在声明时定义，仅存在定义时在定义时定义。

#### 3.C++数组作为参数时不会按值传递，它传递第0个元素的指针，修改时直接修改原变量，非临时变量。

&emsp; ```三个等价的声明：Void putValues(int*)	|	Void putValues(int[])	|	Void putValues(int[10])```

## 2012

#### 1.拷贝构造函数的调用时机：

 1. 对象以值传递传入函数
		如：void g_fun(CExample C){…}
		而传引用时不会调用
 2. 函数以值传递返回对象时
		如：CExample g_fun(){…}
		返回引用时不会调用
 3. 对象通过另一个对象初始化
		如:Point B(A);

		深拷贝：为类中的动态对象重新分配空间；
		浅拷贝：仅仅简单为相同的类成员赋值。

!> 注意：<br>· 默认拷贝构造函数为浅拷贝，若类中有指针等动态对象，将会在拷贝后出错（类中的两个指针指向同一段地址）;<br>· 一个对象初始化另一个对象时调用拷贝构造函数，不调用构造函数。


#### 2.对于类X，有第一个参数是下列之一且没有其他参数或其他参数都有默认值，那么该函数是拷贝构造函数：

- X&
- const X&
- volatile X&
- const volatile X&

#### 3.默认继承关系： 

&emsp; class为private、 struct为public

#### 4.虚函数

&emsp; 以virtual修饰但结尾不加=0的为虚函数，包含该函数的为虚基类，否则为纯虚函数和纯虚基类。用基类指针指向子类函数，调用基类被子类覆盖的函数，则若基类是虚函数，此时关系为继承，此时调用子类函数；时若基类非虚，则关系为覆盖，此时调用基类函数。

#### 5.函数后加const意为该函数不对类成员作修改。函数后加const可作为函数重载。

&emsp; 如：void print() const {…}

#### 6.四种转型：

	static_cast:			原有C的转换方式；
	dynamic_cast:		安全的向下转型，失败时抛出异常；
	const_cast:			用于移除表达式的常量性；
	reinterpret_cast:		用于转换“函数指针”。


## 2010
#### 1.拷贝构造

&emsp; CExample a, b = a; 中 b = a 相当于 b(a)，调用了拷贝构造函数，默认为浅拷贝；

&emsp; CExample &a = b;此时a指向b，即a和b指向同一段地址，此时不调用拷贝构造函数；

#### 2.全局变量，即定义在函数体外的变量，默认值为0；

&emsp; Static修饰的局部变量，默认值为0；

&emsp; 函数每次被调用时，普通局部变量重新分配，静态局部变量保持上次调用的值不变。

#### 3.关于Const关键字

	Const int p; // int p为常量，初始化后不可更改；
	Const int* p; // 常量指针，不能通过*p改变它指向的内容；
	Int const* p; // 常量指针
	Int* const p; // 指针常量，初始化后不能再指向其他内容
	（*在const前修饰指针本身，在后修饰变量）

## 2017
#### 1.类构造顺序：

	基类成员->基类->子类成员->子类
	类析构顺序：子类->子类成员->基类->基类成员

#### 2.成员初始化位置：

- 静态常量数据成员可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化，不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化；
- 静态非常量数据成员只能在类外，即类的实现文件中初始化，也不能在构造函数中初始化，不能在构造函数的初始化列表中初始化；
- 非静态的常量数据成员不能在类内初始化，也不能在构造函数中初始化，而只能且必须在构造函数的初始化列表中初始化；
- 非静态的非常量数据成员不能在类内初始化，可以在构造函数中初始化，也可以在构造函数的初始化列表中初始化；

#### 3.类的继承中构造函数：

&emsp; 基类构造函数必须在子类构造函数的初始化列表中初始化，当基类存在默认构造函数时可以不写，否则必须写。

## 2013
#### 1.多继承中父类的构造顺序与继承列表定义顺序一致；

#### 2.C++类中不能定义自身类的对象，可以定义自身类的指针对象和引用；

#### 3.在函数体中定义的临时类对象在函数体调用结束时不论是否还有指针或引用指向它，最后都会被自动释放；

#### 4.char类型=int 值时，只有值小于ASCII（127）作为int型输出才为正确值，否则输出为0；

#### 5.void main 最后可以用return ;；

#### 6.类继承中，若基类指针指向子类对象，当且仅当基类析构函数为虚析构函数时，子类对象才能正确按照子类->基类的顺序析构，否则将直接按照基类析构；

#### 7.求圆面积

	#define PI acos(float(-1))

## 2011

#### 1.继承下的函数调用：
	a) 基类指针指向子类对象（例：Base* a = &b;）
		i.若基类函数加virtual则为继承，调用子类函数；
		ii.若基类函数未加virtual则调用基类函数；
	b) 子类对象赋值基类对象（例：Base a = b;）
		i.不论基类函数是否virtual，始终调用基类函数；
	c) 基类引用引用一个子类对象（例：Base &a = b;）
		i.此时情况与a)相同

!> 三种情况中均无法调用基类没有而子类有的函数。

#### 2.类模板：
	template<class T>
	class ttt{
		T x,y;
		public:
			ttt(T a, T b): x(a), y(b){}
			T sum(){ return x+y; }
	}

	int main(){
		ttt<double> aaa(9.1, 8.3);
		cout << fixed << setprecision(6) << setfill(‘*’) << setw(12) << aaa.sum() << endl;
	printf(“&012.6f\n”, aaa.sum());
		return 0;
	}

	输出：
			***17.300000
			00017.300000

#### 3.Int\*& p = a代表\*p引用\*a.

